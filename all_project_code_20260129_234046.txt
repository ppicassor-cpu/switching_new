==================================================
   N_BBANG PROJECT SOURCE CODE
   Exported at: 2026-01-29 23:40:46
==================================================


================================================================================
 FILE: app.json
================================================================================

{
  "expo": {
    "name": "ìŠ¤ìœ„ì¹­",
    "slug": "switching",
    "scheme": "switching",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/images/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#000000"
      },
      "package": "com.switching.app",
      "versionCode": 13,
      "config": {
        "googleMobileAdsAppId": "ca-app-pub-5144004139813427~5730965404"
      },
      "navigationBar": {
        "backgroundColor": "#000000",
        "barStyle": "light-content"
      }
    },
    "web": {
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      [
        "react-native-google-mobile-ads",
        {
          "androidAppId": "ca-app-pub-5144004139813427~5730965404",
          "iosAppId": "ca-app-pub-3940256099942544~1458002511",
          "delayAppMeasurementInit": true
        }
      ],
      "expo-build-properties",
      "react-native-iap",
      "./plugins/withAndroidQueries",
      "./plugins/withAppSwitch",
      "./withAndroidSigning.js",
      "./withAutoVersion.js"
    ],
    "extra": {
      "router": {},
      "eas": {
        "projectId": "9446e8e2-b853-40b2-8597-ec2e2385ce09"
      }
    },
    "owner": "son_sunghyun",
    "runtimeVersion": {
      "policy": "appVersion"
    },
    "updates": {
      "url": "https://u.expo.dev/9446e8e2-b853-40b2-8597-ec2e2385ce09",
      "enabled": true,
      "checkOnLaunch": "ALWAYS",
      "fallbackToCacheTimeout": 0
    }
  }
}

================================================================================
 FILE: App.tsx
================================================================================

ï»¿import AsyncStorage from '@react-native-async-storage/async-storage';
import * as NavigationBar from 'expo-navigation-bar';
import React, { useEffect, useRef, useState } from 'react';
import {
  Alert,
  Animated,
  Dimensions,
  FlatList,
  Image,
  Modal,
  NativeEventEmitter,
  NativeModules,
  Platform,
  // SafeAreaView, // âœ… [ìˆ˜ì •] ì œê±° (deprecated ê²½ê³  ì œê±°)
  StatusBar,
  StyleSheet,
  Text,
  TouchableOpacity,
  View
} from 'react-native';
// âœ… [ì¶”ê°€] deprecated ê²½ê³  ì œê±°ìš© SafeAreaView
import { SafeAreaView } from 'react-native-safe-area-context'; // âœ… [ì¶”ê°€]
// âœ… [ìˆ˜ì •] R(ë¦¬ë¡œë“œ) ì‹œ TurboModule ì¤€ë¹„ íƒ€ì´ë° ë¬¸ì œë¡œ í¬ë˜ì‰¬ ë°©ì§€: GMAëŠ” ëŸ°íƒ€ì„ì— ì§€ì—° ë¡œë“œ
import * as IAP from 'react-native-iap';

// ë„¤ì´í‹°ë¸Œ ëª¨ë“ˆ ì—°ê²°
const { AppSwitchModule } = NativeModules;
const eventEmitter = AppSwitchModule ? new NativeEventEmitter(AppSwitchModule) : null;

const INTERSTITIAL_ID = 'ca-app-pub-5144004139813427/8304323709';
const BANNER_ID = 'ca-app-pub-5144004139813427/7182813723';

// âœ… [ìˆ˜ì •] ì „ë©´ê´‘ê³ ë„ PG ì´í•˜ + ë¹„ê°œì¸í™” + ì•„ë™/ë™ì˜ ê´€ë ¨ í”Œë˜ê·¸ ëª…ì‹œ
const INTERSTITIAL_REQUEST_OPTIONS = {
  requestNonPersonalizedAdsOnly: true,
  maxAdContentRating: 'PG',
  tagForChildDirectedTreatment: false,
  tagForUnderAgeOfConsent: false,
};

interface AppInfo {
  label: string;
  packageName: string;
}

interface AppState {
  targetPackage: string;
  isEnabled: boolean;
  isPremium: boolean;
}

const { width } = Dimensions.get('window');

export default function App() {
  const [gma, setGma] = useState<any>(null); 
  const [isEnabled, setIsEnabled] = useState<boolean>(false);
  const fadeAnim = useRef(new Animated.Value(0)).current; // âœ… ê¹œë¹¡ì„ ê°’ ì´ˆê¸°í™”

  // âœ… ì‹œìŠ¤í…œ OFFLINEì¼ ë•Œë§Œ ê¹œë¹¡ì´ëŠ” ë£¨í”„ ì‹¤í–‰
  useEffect(() => {
    if (!isEnabled) {
      Animated.loop(
        Animated.sequence([
          Animated.timing(fadeAnim, { toValue: 1, duration: 800, useNativeDriver: true }),
          Animated.timing(fadeAnim, { toValue: 0, duration: 800, useNativeDriver: true }),
        ])
      ).start();
    } else {
      fadeAnim.setValue(0);
    }
  }, [isEnabled]);
  const interstitialRef = useRef<any>(null); // âœ… [ì¶”ê°€] interstitial ì¸ìŠ¤í„´ìŠ¤ ë³´ê´€

  const [appList, setAppList] = useState<AppInfo[]>([]);
  const [targetPackage, setTargetPackage] = useState<string>('');
  const [targetLabel, setTargetLabel] = useState<string>('');
  const [isPremium, setIsPremium] = useState<boolean>(false);
  const [adLoaded, setAdLoaded] = useState<boolean>(false);
  const [loading, setLoading] = useState(true);
  const [modalVisible, setModalVisible] = useState(false);

  const stateRef = useRef<AppState>({ targetPackage, isEnabled, isPremium });

  useEffect(() => {
    stateRef.current = { targetPackage, isEnabled, isPremium };
  }, [targetPackage, isEnabled, isPremium]);

  useEffect(() => {
    if (Platform.OS === 'android') {
  // ìƒë‹¨ ìƒíƒœë°” íˆ¬ëª…í•˜ê²Œ ë§Œë“¤ì–´ì„œ ë°°ê²½ìƒ‰(ê²€ì •)ê³¼ ì´ì–´ì§€ê²Œ í•¨
  StatusBar.setTranslucent(true);
  StatusBar.setBackgroundColor("transparent");
  // NavigationBar.setBackgroundColorAsync("#000000"); // âœ… [ìˆ˜ì •] edge-to-edge ê²½ê³  ì œê±°(í˜¸ì¶œ ì•ˆ í•¨)
  NavigationBar.setButtonStyleAsync("light");
}

    const checkSubscription = async () => {
      try {
        await IAP.initConnection();
        const purchases = await IAP.getAvailablePurchases();
        const hasSub = purchases.some((p: any) => p.productId === 'monthly_sub' && p.transactionId);
        setIsPremium(hasSub);
      } catch (err) {
        console.warn("êµ¬ë… í™•ì¸ ì‹¤íŒ¨:", err);
      }
    };
    checkSubscription();

    // âœ… [ìˆ˜ì •] GMAëŠ” ì§€ì—° ë¡œë“œ í›„ interstitial ìƒì„±/ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    let mounted = true; // âœ… [ì¶”ê°€]
    let unsubscribeLoaded: any = null; // âœ… [ì¶”ê°€]
    let unsubscribeClosed: any = null; // âœ… [ì¶”ê°€]

    const t = setTimeout(async () => { 
      try {
        const mod = require('react-native-google-mobile-ads'); 
        await mod.default().initialize();
        if (!mounted) return;

        setGma(mod); 

        const ad = mod.InterstitialAd.createForAdRequest(
          INTERSTITIAL_ID,
          INTERSTITIAL_REQUEST_OPTIONS
        ); // âœ… [ì¶”ê°€]
        interstitialRef.current = ad; // âœ… [ì¶”ê°€]

        unsubscribeLoaded = ad.addAdEventListener(mod.AdEventType.LOADED, () => {
          setAdLoaded(true);
        }); // âœ… [ì¶”ê°€]

        unsubscribeClosed = ad.addAdEventListener(mod.AdEventType.CLOSED, () => {
          setAdLoaded(false);
          ad.load();
          launchTargetApp();
        }); // âœ… [ì¶”ê°€]

        ad.load(); // âœ… [ì¶”ê°€]
      } catch (e) {
        console.warn("GMA init skipped (runtime not ready):", e); // âœ… [ì¶”ê°€]
      }
    }, 0);

    const volumeListener = eventEmitter?.addListener('onVolumeDownTrigger', handleVolumeDownTrigger);

    return () => {
      mounted = false; // âœ… [ì¶”ê°€]
      clearTimeout(t); // âœ… [ì¶”ê°€]
      try { unsubscribeLoaded && unsubscribeLoaded(); } catch {} // âœ… [ì¶”ê°€]
      try { unsubscribeClosed && unsubscribeClosed(); } catch {} // âœ… [ì¶”ê°€]
      interstitialRef.current = null; // âœ… [ì¶”ê°€]
      volumeListener?.remove();
      IAP.endConnection();
    };
  }, []);

  useEffect(() => {
    // ì•± êµ¬ë™ ì‹œ ë„¤ì´í‹°ë¸Œ ì €ì¥ì†Œ(SharedPreferences)ì—ì„œ ì €ì¥ëœ ì„¤ì •ê°’ í˜¸ì¶œ
    if (AppSwitchModule?.getSettings) {
      AppSwitchModule.getSettings().then((res: any) => {
        if (res) {
          // ì €ì¥ëœ íŒ¨í‚¤ì§€ ëª…ê³¼ í™œì„±í™” ìƒíƒœë¥¼ UI ìƒíƒœì— ë°˜ì˜
          setTargetPackage(res.targetPackage || '');
          setIsEnabled(res.isEnabled || false);
        }
      });
    }

    if (AppSwitchModule?.getInstalledApps) {
      AppSwitchModule.getInstalledApps()
        .then((apps: AppInfo[]) => {
          const sortedApps = apps.sort((a, b) => a.label.localeCompare(b.label));
          setAppList(sortedApps);
          setLoading(false);
        })
        .catch(() => {
          setLoading(false);
        });
    } else {
      setLoading(false);
    }
  }, []);

  const handleVolumeDownTrigger = async () => {
    const { targetPackage: pkg, isEnabled: enabled, isPremium: premium } = stateRef.current;

    if (!enabled || !pkg) return;

    if (premium) {
      launchTargetApp();
      return;
    }

    const lastAdTime = await AsyncStorage.getItem('last_ad_time');
    const now = Date.now();
    const oneHour = 60 * 60 * 1000;

    if (lastAdTime && now - parseInt(lastAdTime) < oneHour) {
      launchTargetApp();
    } else {
      if (adLoaded && interstitialRef.current?.show) { // âœ… [ìˆ˜ì •]
        await AsyncStorage.setItem('last_ad_time', now.toString());
        interstitialRef.current.show(); // âœ… [ìˆ˜ì •]
      } else {
        launchTargetApp();
      }
    }
  };

  const launchTargetApp = () => {
    const { targetPackage: pkg } = stateRef.current;
    if (pkg && AppSwitchModule?.launchApp) {
      AppSwitchModule.launchApp(pkg);
    }
  };

  const handleSaveWithLogic = async () => {
    if (!targetPackage) {
      Alert.alert("ì•Œë¦¼", "ì•±ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
      return;
    }

    if (isPremium) {
      saveSettings();
      return;
    }

    Alert.alert(
      "ì„¤ì • ì™„ë£Œ",
      "ê¸°ëŠ¥(ë³¼ë¥¨ ë‹¤ìš´) ì‚¬ìš© ì‹œ ì „ë©´ ê´‘ê³ ê°€ ì‹¤í–‰ë˜ë©°, ì´í›„ 1ì‹œê°„ ë™ì•ˆì€ ê´‘ê³  ì—†ì´ ì‘ë™í•©ë‹ˆë‹¤.\nì ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
      [
        { text: "ì·¨ì†Œ", style: "cancel" },
        { text: "í™•ì¸", onPress: () => saveSettings() }
      ]
    );
  };

  const saveSettings = () => {
    if (AppSwitchModule?.saveSettings) {
      // ë„¤ì´í‹°ë¸Œ ëª¨ë“ˆì˜ ì¸ì ê°œìˆ˜(2ê°œ)ì— ë§ì¶° í˜¸ì¶œ (íŒ¨í‚¤ì§€ëª…, í™œì„±í™” ì—¬ë¶€)
      AppSwitchModule.saveSettings(targetPackage, isEnabled);
      Alert.alert("ì €ì¥ ì„±ê³µ", `[${targetLabel}] ì„¤ì •ì´ ì‹œìŠ¤í…œì— ë°˜ì˜ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    }
  };

  const toggleEnabledByLogo = async () => {
    // 1. ì‹œìŠ¤í…œì„ ì¼œë ¤ê³  í•  ë•Œë§Œ ê¶Œí•œ ì²´í¬ ìˆ˜í–‰
    if (!isEnabled) {
      if (AppSwitchModule?.isAccessibilityServiceEnabled) {
        const isGranted = await AppSwitchModule.isAccessibilityServiceEnabled();
        if (!isGranted) {
          Alert.alert(
            "ì ‘ê·¼ì„± ê¶Œí•œ í•„ìš”",
            "ë³¼ë¥¨ í‚¤ë¥¼ ê°ì§€í•˜ë ¤ë©´ ì ‘ê·¼ì„± ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.\n\n[ì„¤ì • ì´ë™] í›„ 'ì„¤ì¹˜ëœ ì•±' ëª©ë¡ì—ì„œ [ìŠ¤ìœ„ì¹­ ì„œë¹„ìŠ¤]ë¥¼ 'ì‚¬ìš©'ìœ¼ë¡œ ë°”ê¿”ì£¼ì„¸ìš”.",
            [
              { text: "ë‚˜ì¤‘ì—", style: "cancel" },
              { text: "ì„¤ì • ì´ë™", onPress: () => AppSwitchModule.openAccessibilitySettings() }
            ]
          );
          return; // ê¶Œí•œ ì—†ìœ¼ë©´ 'Online'ìœ¼ë¡œ ë„˜ì–´ê°€ì§€ ì•ŠìŒ
        }
      }
    }

    // 2. ê¶Œí•œì´ ìˆê±°ë‚˜ ì‹œìŠ¤í…œì„ ëŒ ë•ŒëŠ” ê¸°ì¡´ ë¡œì§ ìˆ˜í–‰
    setIsEnabled((prev) => {
      const nextState = !prev;
      if (AppSwitchModule?.saveSettings) {
        // [ì°¸ê³ ] ë„¤ì´í‹°ë¸Œ ì„¤ê³„ì— ë§ì¶° ì¸ìë¥¼ ì „ë‹¬í•˜ì„¸ìš” (ì´ì „ ê°€ì´ë“œì—ì„  2ê°œë¡œ ì¡°ì •ë¨)
        AppSwitchModule.saveSettings(targetPackage, nextState);
      }
      return nextState;
    });
  };

  const renderItem = ({ item }: { item: AppInfo }) => (
    <TouchableOpacity
      style={[styles.appItem, targetPackage === item.packageName && styles.selectedItem]}
      onPress={() => {
        setTargetPackage(item.packageName);
        setTargetLabel(item.label);
        setModalVisible(false);
      }}
    >
      <View>
        <Text style={styles.appLabel}>{item.label}</Text>
        <Text style={styles.appPackage}>{item.packageName}</Text>
      </View>
      {targetPackage === item.packageName && <Text style={styles.checkIcon}>âœ“</Text>}
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      {/* ìƒíƒœë°”ëŠ” íˆ¬ëª…í•˜ê²Œ ì²˜ë¦¬ */}
      <StatusBar barStyle="light-content" translucent={true} backgroundColor="transparent" />

      <SafeAreaView style={styles.safeArea} edges={['left', 'right', 'bottom']}>
        {/* 1. ìƒë‹¨: í”„ë¦¬ë¯¸ì—„ ë±ƒì§€ (ì‹œìŠ¤í…œ ì˜ì—­ ì¹¨ë²” ë°©ì§€ìš© ë§ˆì§„ ì¶”ê°€) */}
        <View style={styles.headerArea}>
          <View style={[styles.premiumBadge, isPremium ? styles.badgePremium : styles.badgeFree]}>
            <Text style={styles.premiumText}>
               {isPremium ? "ğŸ’ PREMIUM" : "FREE VERSION"}
            </Text>
          </View>
        </View>

        {/* 2. ë©”ì¸ ì»¨í…ì¸  (ê°€ìš´ë° ì •ë ¬) */}
        <View style={styles.mainContent}>

          {/* âœ… ì‹œìŠ¤í…œì´ êº¼ì ¸ ìˆì„ ë•Œë§Œ ê¹œë¹¡ì´ëŠ” íŒíŠ¸ í‘œì‹œ */}
          {!isEnabled && (
            <Animated.View style={[styles.hintContainer, { opacity: fadeAnim }]}>
              <Text style={styles.handEmoji}>ğŸ‘‡ </Text>
              <Text style={styles.hintText}>TAP to{"\n"}START</Text>
            </Animated.View>
          )}
          
          {/* ë©”ì¸ ë¡œê³  (Glow íš¨ê³¼ ì ìš©) */}
          <TouchableOpacity 
              onPress={toggleEnabledByLogo} 
              activeOpacity={0.9} 
              style={[styles.logoContainer, isEnabled && styles.logoGlow]}
          >
            <Image
              source={
                isEnabled
                  ? require('./assets/app-logo2.png')
                  : require('./assets/app-logo.png')
              }
              style={[styles.logoImage, { opacity: isEnabled ? 1 : 0.4 }]} // êº¼ì§€ë©´ ë” íë¦¬ê²Œ
              resizeMode="contain"
            />
          </TouchableOpacity>
          
          {/* ìƒíƒœ ë©”ì‹œì§€ */}
          <Text style={[styles.statusLabel, { color: isEnabled ? '#1dd4f5' : '#555' }]}>
              {isEnabled ? "System Online" : "System Offline"}
          </Text>

          {/* ì•± ì„ íƒ ì¹´ë“œ UI */}
          <View style={styles.cardContainer}>
              <Text style={styles.cardLabel}>TARGET APP</Text>
              <TouchableOpacity 
                  style={styles.appCard} 
                  onPress={() => setModalVisible(true)}
                  activeOpacity={0.7}
              >
                  <View style={[styles.cardIcon, { backgroundColor: targetLabel ? '#007AFF' : '#222' }]}>
                      <Text style={styles.cardIconText}>{targetLabel ? targetLabel.charAt(0) : '?'}</Text>
                  </View>
                  <View style={styles.cardInfo}>
                      <Text style={styles.cardTitle} numberOfLines={1}>
                          {targetLabel || "ì•± ì„ íƒí•˜ê¸°"}
                      </Text>
                      <Text style={styles.cardSubTitle} numberOfLines={1}>
                          {targetPackage || "Touch to select target"}
                      </Text>
                  </View>
                  <View style={styles.cardArrow}>
                      <Text style={styles.arrowText}>â€º</Text>
                  </View>
              </TouchableOpacity>
          </View>
        </View>

        {/* 3. í•˜ë‹¨: í”Œë¡œíŒ… ì €ì¥ ë²„íŠ¼ (ì„¸ë ¨ë˜ê³  ì‘ê²Œ ë³€ê²½) */}
        <View style={styles.footerArea}>
          <TouchableOpacity style={styles.fabButton} onPress={handleSaveWithLogic}>
              <Text style={styles.fabIcon}>ğŸ’¾</Text>
              <Text style={styles.fabText}>Save</Text>
          </TouchableOpacity>
        </View>


        {/* 4. ê´‘ê³  ì˜ì—­ (ì‹œìŠ¤í…œ ë„¤ë¹„ê²Œì´ì…˜ ë°”ì™€ ê²¹ì¹˜ì§€ ì•Šê²Œ íŒ¨ë”© ì¶”ê°€) */}
        <View style={styles.adContainer}>
          {gma?.BannerAd && gma?.BannerAdSize ? ( // âœ… [ìˆ˜ì •] ëŸ°íƒ€ì„ ì¤€ë¹„ ì „ì—” ë Œë”í•˜ì§€ ì•ŠìŒ
            <gma.BannerAd
              unitId={BANNER_ID}
              size={gma.BannerAdSize.ANCHORED_ADAPTIVE_BANNER}
              requestOptions={{ // âœ… [ìˆ˜ì •]
                requestNonPersonalizedAdsOnly: true,
                maxAdContentRating: 'PG',
                tagForChildDirectedTreatment: false,
                tagForUnderAgeOfConsent: false,
              }}
            />
          ) : null}
        </View>

        {/* 5. ëª¨ë‹¬ */}
        <Modal
          animationType="fade"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => setModalVisible(false)}
        >
          <View style={styles.modalOverlay}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Select App</Text>
                <TouchableOpacity onPress={() => setModalVisible(false)} style={styles.closeBtn}>
                  <Text style={styles.closeText}>âœ•</Text>
                </TouchableOpacity>
              </View>
              {loading ? (
                <Text style={styles.emptyText}>Loading apps...</Text>
              ) : (
                <FlatList
                  data={appList}
                  renderItem={renderItem}
                  keyExtractor={(item) => item.packageName}
                  contentContainerStyle={styles.listContent}
                  ListEmptyComponent={<Text style={styles.emptyText}>No apps found.</Text>}
                  indicatorStyle="white"
                />
              )}
            </View>
          </View>
        </Modal>

      </SafeAreaView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#050505' },
  safeArea: { flex: 1 },

  // ìƒë‹¨ ì˜ì—­ (ì‹œìŠ¤í…œ ìƒíƒœë°” ê³ ë ¤í•˜ì—¬ ë§ˆì§„ ì¶”ê°€)
  headerArea: {
    height: 50,
    justifyContent: 'center',
    alignItems: 'flex-end',
    paddingHorizontal: 20,
    marginTop: Platform.OS === 'android'
      ? (StatusBar.currentHeight || 20) + 5
      : 10 + 12,                                  // âœ… [ìˆ˜ì •] iOSë„ ë™ì¼í•˜ê²Œ ì•„ë˜ë¡œ
    zIndex: 10
  },
  premiumBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    borderWidth: 1,
  },
  badgeFree: { backgroundColor: 'rgba(255,255,255,0.05)', borderColor: '#333' },
  badgePremium: { backgroundColor: 'rgba(0,122,255,0.15)', borderColor: '#0052D4' },
  premiumText: { fontSize: 9, fontWeight: '800', color: '#ccc', letterSpacing: 0.5 },

  // ë©”ì¸ ì˜ì—­
  mainContent: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingBottom: 80 // í•˜ë‹¨ ë²„íŠ¼ ê³µê°„ í™•ë³´
  },
  logoContainer: {
    marginBottom: 25,
    borderRadius: 100,
  },
  logoImage: { width: 160, height: 160 },
  logoGlow: {
    shadowColor: '#dae1e7',
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.9,
    shadowRadius: 40,
    elevation: 25,
  },
  statusLabel: {
    fontSize: 13,
    fontWeight: '600',
    letterSpacing: 0.8,
    marginBottom: 40,
    textTransform: 'uppercase'
  },

  // ì¹´ë“œ UI ì˜ì—­
  cardContainer: { width: '85%', maxWidth: 340 },
  cardLabel: {
    color: '#666',
    fontSize: 11,
    fontWeight: '700',
    marginBottom: 8,
    marginLeft: 4,
    letterSpacing: 0.5
  },
  appCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#121212',
    borderRadius: 16,
    padding: 14,
    borderWidth: 1,
    borderColor: '#2a2a2a'
  },
  cardIcon: {
    width: 38,
    height: 38,
    borderRadius: 10,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 14
  },
  cardIconText: { fontSize: 18, color: '#fff', fontWeight: 'bold' },
  cardInfo: { flex: 1 },
  cardTitle: { color: '#eee', fontSize: 15, fontWeight: '600', marginBottom: 2 },
  cardSubTitle: { color: '#555', fontSize: 11 },
  cardArrow: { paddingLeft: 10 },
  arrowText: { color: '#444', fontSize: 20 },

  // í•˜ë‹¨ ì˜ì—­ (ê´‘ê³ ì™€ ê±°ë¦¬ë¥¼ ë” ë‘ì–´ ì—¬ìœ ë¡­ê²Œ ë°°ì¹˜)
  footerArea: {
    position: 'absolute',
    bottom: Platform.OS === 'android' ? 200 :190, 
    width: '100%',
    alignItems: 'center',
    zIndex: 20
  },
  fabButton: {
    flexDirection: 'row',
    backgroundColor: 'rgba(255, 255, 255, 0.05)', // ì•„ì£¼ ë¯¸ì„¸í•œ íˆ¬ëª…ê°
    paddingVertical: 10,
    paddingHorizontal: 40,       // ê°€ë¡œë¡œ ê¸¸ê²Œ ë¹¼ì„œ ì•ˆì •ê° ë¶€ì—¬
    borderRadius: 4,              // ê°ì„ ê±°ì˜ ì‚´ë¦° ì´ˆë¯¸ë‹ˆë©€ ë¼ìš´ë“œ
    alignItems: 'center',
    borderWidth: 0.9,           // ì•„ì£¼ ê°€ëŠë‹¤ë€ ì„ 
    borderColor: '#49a0c2',          // ëˆˆì— ë„ì§€ ì•ŠëŠ” ì°¨ë¶„í•œ ê·¸ë ˆì´
  },
  fabIcon: { display: 'none' },   // ì´ŒìŠ¤ëŸ¬ìš´ ì•„ì´ì½˜ì€ ì™„ì „íˆ ì œê±°
  fabText: { 
    color: '#c8d0d4',             // ê¹”ë”í•œ í™”ì´íŠ¸
    fontSize: 12, 
    fontWeight: '400',            // ì–‡ì€ ì„œì²´ë¡œ ì„¸ë ¨ë¯¸ ê°•ì¡°
    letterSpacing: 2,            // ìê°„ì„ ë„“ê²Œ ë²Œë ¤ ì—¬ë°±ì˜ ë¯¸ ê°•ì¡°
    textTransform: 'uppercase'
  },

  // ê´‘ê³  ì˜ì—­ (ë¯¸ë¦¬ ë†’ì´ë¥¼ ê³ ì •í•˜ì—¬ ë ˆì´ì•„ì›ƒ í”ë“¤ë¦¼ ë°©ì§€)
  adContainer: {
    width: '100%',
    height: 60, // âœ… ê´‘ê³  ë†’ì´(ë³´í†µ 50~60)ë§Œí¼ ë¯¸ë¦¬ ìë¦¬ë¥¼ ê³ ì •í•©ë‹ˆë‹¤.
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#000'
  },

  // ëª¨ë‹¬ ìŠ¤íƒ€ì¼
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.9)', justifyContent: 'center', alignItems: 'center' },
  modalContent: {
    width: '85%',
    height: '65%',
    backgroundColor: '#111',
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#222',
    overflow: 'hidden'
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 18,
    borderBottomWidth: 1,
    borderBottomColor: '#222',
    backgroundColor: '#161616'
  },
  modalTitle: { color: '#fff', fontSize: 16, fontWeight: 'bold' },
  closeBtn: { padding: 5 },
  closeText: { color: '#666', fontSize: 18 },
  listContent: { padding: 10 },
  appItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 14,
    marginBottom: 6,
    borderRadius: 12,
    backgroundColor: '#1A1A1A'
  },
  selectedItem: { backgroundColor: '#111', borderColor: '#007AFF', borderWidth: 1 },
  appLabel: { fontSize: 15, fontWeight: '500', color: '#eee' },
  appPackage: { fontSize: 11, color: '#555', marginTop: 2 },
  checkIcon: { color: '#007AFF', fontWeight: 'bold', fontSize: 16, position: 'absolute', right: 15 },
  emptyText: { color: '#444', textAlign: 'center', marginTop: 50, fontSize: 12 },
  // âœ… í…Œë‘ë¦¬ ë°•ìŠ¤ë¥¼ ì œê±°í•˜ê³  ì†ëª¨ì–‘ê³¼ ê¸€ìë§Œ ë‚¨ê¹€
  hintContainer: {
    position: 'absolute',
    flexDirection: 'row', 
    alignItems: 'center', 
    top: 80,             // âœ… 50ì—ì„œ 110ìœ¼ë¡œ ëŠ˜ë ¤ ë” ì•„ë˜ë¡œ ì´ë™
    right: '12%',         // âœ… 10%ì—ì„œ 25%ë¡œ ëŠ˜ë ¤ ë” ì™¼ìª½ìœ¼ë¡œ ì´ë™
    zIndex: 30,
  },
  hintText: {
    color: '#cccccc',
    fontSize: 10,
    fontWeight: '900',
    letterSpacing: 0.5,
    textAlign: 'left',    // âœ… ì™¼ìª½ ì •ë ¬ë¡œ ë³€ê²½
    lineHeight: 12,       // âœ… ë‘ ì¤„ ê°„ê²© ì¢ê²Œ ìœ ì§€
    marginLeft: -4,
  },
  handEmoji: {
    fontSize: 20,
    transform: [{ rotate: '45deg' }],
    },
});

================================================================================
 FILE: eslint.config.js
================================================================================

// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);


================================================================================
 FILE: package.json
================================================================================

{
  "name": "switching_new",
  "main": "node_modules/expo/AppEntry.js",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "lint": "expo lint",
    "build:final": "npx expo prebuild --clean && cd android && gradlew.bat app:bundleRelease && cd .. && node rename-bundle.js"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "2.2.0",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "expo": "~54.0.32",
    "expo-build-properties": "~1.0.10",
    "expo-constants": "~18.0.13",
    "expo-font": "~14.0.11",
    "expo-haptics": "~15.0.8",
    "expo-image": "~3.0.11",
    "expo-linking": "~8.0.11",
    "expo-navigation-bar": "~5.0.10",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-symbols": "~1.0.8",
    "expo-system-ui": "~6.0.9",
    "expo-updates": "~29.0.16",
    "expo-web-browser": "~15.0.10",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-google-mobile-ads": "^16.0.2",
    "react-native-iap": "^14.7.7",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}

================================================================================
 FILE: rename-bundle.js
================================================================================

const fs = require('fs');
const path = require('path');

// 1. ì„¤ì • ë° ê²½ë¡œ ì •ì˜
const appJsonPath = path.resolve('app.json');
const bundleDir = path.join('android', 'app', 'build', 'outputs', 'bundle', 'release');
const sourceFile = path.join(bundleDir, 'app-release.aab');

// 2. ë²„ì „ ë° ë‚ ì§œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
const appJson = JSON.parse(fs.readFileSync(appJsonPath, 'utf-8'));
const versionCode = appJson.expo.android?.versionCode || 'unknown';
const appName = appJson.expo.slug || 'myapp';

const now = new Date();
const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;

// 3. ìƒˆ íŒŒì¼ëª… ìƒì„± (ì˜ˆ: Whatflix-v12-20260129.aab)
const newFileName = `${appName}-v${versionCode}-${dateStr}.aab`;
const targetFile = path.join(bundleDir, newFileName);

// 4. íŒŒì¼ ì´ë¦„ ë³€ê²½ ì‹¤í–‰
if (fs.existsSync(sourceFile)) {
  fs.copyFileSync(sourceFile, path.join(path.resolve(), newFileName)); // ë£¨íŠ¸ í´ë”ë¡œ ë³µì‚¬
  console.log('--------------------------------------------------');
  console.log(`âœ… ê´€ë¦¬ìš© íŒŒì¼ ìƒì„± ì™„ë£Œ!`);
  console.log(`ğŸ“‚ íŒŒì¼ëª…: ${newFileName}`);
  console.log(`ğŸ“ ìœ„ì¹˜: í”„ë¡œì íŠ¸ ë£¨íŠ¸ í´ë”`);
  console.log('--------------------------------------------------');
} else {
  console.error('âŒ ë¹Œë“œëœ .aab íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¹Œë“œê°€ ì„±ê³µí–ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
}

================================================================================
 FILE: tsconfig.json
================================================================================

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ]
}


================================================================================
 FILE: withAndroidSigning.js
================================================================================

// FILE: plugins/withAndroidSigning.js
const { withAppBuildGradle } = require("@expo/config-plugins");

/**
 * Gradle(groovy) í…ìŠ¤íŠ¸ì—ì„œ íŠ¹ì • ë¸”ë¡(ì˜ˆ: signingConfigs { ... })ì„
 * ì¤‘ê´„í˜¸ ê¹Šì´ë¡œ ì•ˆì „í•˜ê²Œ ì°¾ì•„ ì œê±°í•©ë‹ˆë‹¤. (ì •ê·œì‹ìœ¼ë¡œ ìƒìœ„ }ê¹Œì§€ ë¨¹ëŠ” ì‚¬ê³  ë°©ì§€)
 */
function removeBlockAll(src, blockName) {
  let out = src;
  while (true) {
    const re = new RegExp(`(^|\\s)${blockName}\\s*\\{`, "m");
    const m = re.exec(out);
    if (!m) break;

    const start = m.index + m[1].length;
    const braceStart = out.indexOf("{", start);
    if (braceStart < 0) break;

    let depth = 0;
    let end = -1;

    for (let i = braceStart; i < out.length; i++) {
      const ch = out[i];
      if (ch === "{") depth++;
      else if (ch === "}") {
        depth--;
        if (depth === 0) {
          end = i;
          break;
        }
      }
    }

    if (end < 0) break;

    // ë¸”ë¡ ì•ë’¤ ê³µë°±/ê°œí–‰ ì¡°ê¸ˆ ì •ë¦¬
    const before = out.slice(0, start);
    const after = out.slice(end + 1);
    out = before.replace(/[ \t]*$/m, "") + "\n" + after.replace(/^\s*\n/, "");
  }
  return out;
}

function findBlock(src, blockName) {
  const re = new RegExp(`(^[\\t ]*)${blockName}\\s*\\{`, "m");
  const m = re.exec(src);
  if (!m) return null;

  const blockStart = m.index;
  const braceStart = src.indexOf("{", blockStart);
  if (braceStart < 0) return null;

  let depth = 0;
  let end = -1;

  for (let i = braceStart; i < src.length; i++) {
    const ch = src[i];
    if (ch === "{") depth++;
    else if (ch === "}") {
      depth--;
      if (depth === 0) {
        end = i;
        break;
      }
    }
  }
  if (end < 0) return null;

  return {
    start: blockStart,
    end: end + 1, // inclusive end -> exclusive index
    indent: m[1] || "",
    text: src.slice(blockStart, end + 1),
  };
}

function upsertSigningConfigLine(buildTypeBlockText, typeName, signingLine) {
  const typeBlock = findBlock(buildTypeBlockText, typeName);
  if (!typeBlock) return buildTypeBlockText;

  const headerEnd = typeBlock.text.indexOf("{") + 1;
  const head = typeBlock.text.slice(0, headerEnd);
  let body = typeBlock.text.slice(headerEnd, -1); // without last "}"

  // ê¸°ì¡´ signingConfig ë¼ì¸ ì œê±°
  body = body.replace(/^\s*signingConfig\s+signingConfigs\..*$/gm, "").replace(/\n{3,}/g, "\n\n");

  // ë“¤ì—¬ì“°ê¸° ê³„ì‚° (type ë¸”ë¡ indent + 4ì¹¸)
  const baseIndentMatch = new RegExp(`(^[\\t ]*)${typeName}\\s*\\{`, "m").exec(typeBlock.text);
  const baseIndent = baseIndentMatch ? baseIndentMatch[1] : "";
  const innerIndent = baseIndent + "    ";

  // signingConfig ì‚½ì…(ë¸”ë¡ ìµœìƒë‹¨)
  const insert = `\n${innerIndent}${signingLine}\n`;
  const newTypeText = head + insert + body.replace(/^\s*\n/, "\n") + "}";

  // ì›ë³¸ buildTypes ë¸”ë¡ ë‚´ì—ì„œ êµì²´
  return (
    buildTypeBlockText.slice(0, typeBlock.start) +
    newTypeText +
    buildTypeBlockText.slice(typeBlock.end)
  );
}

module.exports = function withAndroidSigning(config) {
  return withAppBuildGradle(config, (config) => {
    if (config.modResults.language !== "groovy") return config;

    let contents = config.modResults.contents;

    // 0) android ë¸”ë¡ì´ ì—†ìœ¼ë©´ ê±´ë“œë¦¬ì§€ ì•ŠìŒ
    const androidBlock = findBlock(contents, "android");
    if (!androidBlock) {
      config.modResults.contents = contents;
      return config;
    }

    // 1) ê¸°ì¡´ signingConfigs ë¸”ë¡ì€ ì•ˆì „í•˜ê²Œ ì „ë¶€ ì œê±°(ì¤‘ë³µ/ê¼¬ì„ ë°©ì§€)
    contents = removeBlockAll(contents, "signingConfigs");

    // 2) ìš°ë¦¬ê°€ ì›í•˜ëŠ” signingConfigs ë¸”ë¡(ê³ ì • í‚¤) ì£¼ì…(ì¤‘ë³µ ë°©ì§€: í‚¤ íŒŒì¼ëª…ìœ¼ë¡œ ì²´í¬)
    const signingConfigsText = `
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }
        release {
            storeFile file("../../my-release-key.keystore")
            storePassword "123456"
            keyAlias "my-key-alias"
            keyPassword "123456"
        }
    }
`;

    if (!contents.includes("my-release-key.keystore")) {
      contents = contents.replace(/android\s*\{/, (m) => `${m}${signingConfigsText}`);
    }

    // 3) buildTypes ë¸”ë¡ì„ ì°¾ì•„ì„œ debug/releaseì— signingConfigë¥¼ ê°•ì œ ì£¼ì…(ê¸°ì¡´ ì˜µì…˜ì€ ìœ ì§€)
    const bt = findBlock(contents, "buildTypes");
    if (bt) {
      let btText = bt.text;

      // debug / release ë¸”ë¡ì— signingConfig ê°•ì œ
      btText = upsertSigningConfigLine(btText, "debug", "signingConfig signingConfigs.debug");
      btText = upsertSigningConfigLine(btText, "release", "signingConfig signingConfigs.release");

      contents = contents.slice(0, bt.start) + btText + contents.slice(bt.end);
    }

    config.modResults.contents = contents;
    return config;
  });
};


================================================================================
 FILE: withAutoVersion.js
================================================================================

const fs = require('fs');
const path = require('path');

global.VERSION_UPDATED = global.VERSION_UPDATED || false;

module.exports = function withAutoVersion(config) {
  // 1. í•µì‹¬ ì•ˆì „ì¥ì¹˜: ì‹¤í–‰ ì¸ìì— 'prebuild'ë‚˜ 'build'ê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  const isTargetCommand = process.argv.some(arg => 
    arg.includes('prebuild') || arg.includes('build')
  );

  // ë¹Œë“œ ê´€ë ¨ ëª…ë ¹ì–´ê°€ ì•„ë‹ˆë©´(ì˜ˆ: expo start) ê·¸ëƒ¥ ë¦¬í„´
  if (!isTargetCommand || global.VERSION_UPDATED) {
    return config;
  }

  const appJsonPath = path.resolve('app.json');

  if (fs.existsSync(appJsonPath)) {
    const appJson = JSON.parse(fs.readFileSync(appJsonPath, 'utf-8'));
    const currentCode = appJson.expo.android?.versionCode || 0;
    const nextCode = currentCode + 1;

    if (!appJson.expo.android) appJson.expo.android = {};
    appJson.expo.android.versionCode = nextCode;
    
    fs.writeFileSync(appJsonPath, JSON.stringify(appJson, null, 2));

    if (!config.android) config.android = {};
    config.android.versionCode = nextCode;

    global.VERSION_UPDATED = true;
    console.log(`ğŸš€ [AutoVersion] ë¹Œë“œ ëª¨ë“œ ê°ì§€: versionCodeë¥¼ ${nextCode}ë¡œ ì—…ë°ì´íŠ¸í–ˆìŠµë‹ˆë‹¤.`);
  }

  return config;
};

================================================================================
 FILE: .vscode\extensions.json
================================================================================

{ "recommendations": ["expo.vscode-expo-tools"] }


================================================================================
 FILE: .vscode\settings.json
================================================================================

{
  "editor.codeActionsOnSave": {
    "source.fixAll": "explicit",
    "source.organizeImports": "explicit",
    "source.sortMembers": "explicit"
  }
}


================================================================================
 FILE: components\external-link.tsx
================================================================================

import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}


================================================================================
 FILE: components\haptic-tab.tsx
================================================================================

import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}


================================================================================
 FILE: components\hello-wave.tsx
================================================================================

import Animated from 'react-native-reanimated';

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          '50%': { transform: [{ rotate: '25deg' }] },
        },
        animationIterationCount: 4,
        animationDuration: '300ms',
      }}>
      ğŸ‘‹
    </Animated.Text>
  );
}


================================================================================
 FILE: components\parallax-scroll-view.tsx
================================================================================

import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/themed-view';
import { useColorScheme } from '@/hooks/use-color-scheme';
import { useThemeColor } from '@/hooks/use-theme-color';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const backgroundColor = useThemeColor({}, 'background');
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <Animated.ScrollView
      ref={scrollRef}
      style={{ backgroundColor, flex: 1 }}
      scrollEventThrottle={16}>
      <Animated.View
        style={[
          styles.header,
          { backgroundColor: headerBackgroundColor[colorScheme] },
          headerAnimatedStyle,
        ]}>
        {headerImage}
      </Animated.View>
      <ThemedView style={styles.content}>{children}</ThemedView>
    </Animated.ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});


================================================================================
 FILE: components\themed-text.tsx
================================================================================

import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});


================================================================================
 FILE: components\themed-view.tsx
================================================================================

import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}


================================================================================
 FILE: components\ui\collapsible.tsx
================================================================================

import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { IconSymbol } from '@/components/ui/icon-symbol';
import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});


================================================================================
 FILE: components\ui\icon-symbol.ios.tsx
================================================================================

import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}


================================================================================
 FILE: components\ui\icon-symbol.tsx
================================================================================

// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight, SymbolViewProps } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}


================================================================================
 FILE: constants\theme.ts
================================================================================

/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

import { Platform } from 'react-native';

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

export const Fonts = Platform.select({
  ios: {
    /** iOS `UIFontDescriptorSystemDesignDefault` */
    sans: 'system-ui',
    /** iOS `UIFontDescriptorSystemDesignSerif` */
    serif: 'ui-serif',
    /** iOS `UIFontDescriptorSystemDesignRounded` */
    rounded: 'ui-rounded',
    /** iOS `UIFontDescriptorSystemDesignMonospaced` */
    mono: 'ui-monospace',
  },
  default: {
    sans: 'normal',
    serif: 'serif',
    rounded: 'normal',
    mono: 'monospace',
  },
  web: {
    sans: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    serif: "Georgia, 'Times New Roman', serif",
    rounded: "'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif",
    mono: "SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
});


================================================================================
 FILE: hooks\use-color-scheme.ts
================================================================================

export { useColorScheme } from 'react-native';


================================================================================
 FILE: hooks\use-color-scheme.web.ts
================================================================================

import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}


================================================================================
 FILE: hooks\use-theme-color.ts
================================================================================

/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}


================================================================================
 FILE: plugins\withAndroidQueries.js
================================================================================

const { withAndroidManifest } = require("@expo/config-plugins");

module.exports = function withAndroidQueries(config) {
  return withAndroidManifest(config, (config) => {
    const manifest = config.modResults.manifest;

    // 1. ëª¨ë“  ì•± ê²€ìƒ‰ ê¶Œí•œ(QUERY_ALL_PACKAGES) ì¶”ê°€ ë¡œì§
    if (!manifest["uses-permission"]) {
      manifest["uses-permission"] = [];
    }

    const hasQueryPermission = manifest["uses-permission"].some(
      (p) => p.$["android:name"] === "android.permission.QUERY_ALL_PACKAGES"
    );

    if (!hasQueryPermission) {
      manifest["uses-permission"].push({
        $: { "android:name": "android.permission.QUERY_ALL_PACKAGES" },
      });
    }

    // 2. ì•± ì‹¤í–‰(LAUNCHER) ì¿¼ë¦¬ ì¶”ê°€ ë¡œì§
    if (!manifest.queries) {
      manifest.queries = [];
    }

    const hasLauncherQuery = manifest.queries.some((q) => {
      const intent = q?.intent?.[0];
      const action = intent?.action?.[0]?.$?.["android:name"];
      const category = intent?.category?.[0]?.$?.["android:name"];
      return (
        action === "android.intent.action.MAIN" &&
        category === "android.intent.category.LAUNCHER"
      );
    });

    if (!hasLauncherQuery) {
      manifest.queries.push({
        intent: [
          {
            action: [{ $: { "android:name": "android.intent.action.MAIN" } }],
            category: [{ $: { "android:name": "android.intent.category.LAUNCHER" } }],
          },
        ],
      });
    }

    return config;
  });
};

================================================================================
 FILE: plugins\withAppSwitch.js
================================================================================

const { withAndroidManifest, withDangerousMod, withMainApplication } = require("@expo/config-plugins");
const fs = require("fs");
const path = require("path");

module.exports = function withAppSwitch(config) {
  // 1. AndroidManifest.xml ìˆ˜ì •
  config = withAndroidManifest(config, (config) => {
    const manifest = config.modResults.manifest;
    const mainApplication = manifest.application[0];

    if (!manifest["uses-permission"]) manifest["uses-permission"] = [];
    
    const permissions = [
      "android.permission.FOREGROUND_SERVICE",
      "android.permission.FOREGROUND_SERVICE_SPECIAL_USE",
      "android.permission.BIND_ACCESSIBILITY_SERVICE",
      "android.permission.QUERY_ALL_PACKAGES"
    ];

    permissions.forEach(perm => {
      if (!manifest["uses-permission"].some(p => p.$["android:name"] === perm)) {
        manifest["uses-permission"].push({ $: { "android:name": perm } });
      }
    });

    // âœ… [ì¶”ê°€] Android 11+ íŒ¨í‚¤ì§€ ê°€ì‹œì„±: getLaunchIntentForPackage / íƒ€ ì•± ì‹¤í–‰ ëŒ€ë¹„ queries ë³´ì¥
    if (!manifest["queries"]) manifest["queries"] = [];

    const hasQuery = (actionName, categoryName, scheme) =>
      (manifest["queries"] || []).some(q =>
        (q.intent || []).some(i => {
          const actions = i.action || [];
          const categories = i.category || [];
          const datas = i.data || [];
          const okAction = actions.some(a => a?.$?.["android:name"] === actionName);
          const okCategory = categories.some(c => c?.$?.["android:name"] === categoryName);
          const okScheme = scheme ? datas.some(d => d?.$?.["android:scheme"] === scheme) : true;
          return okAction && okCategory && okScheme;
        })
      );

    if (!hasQuery("android.intent.action.MAIN", "android.intent.category.LAUNCHER", null)) {
      manifest["queries"].push({
        intent: [{
          action: [{ $: { "android:name": "android.intent.action.MAIN" } }],
          category: [{ $: { "android:name": "android.intent.category.LAUNCHER" } }],
        }],
      });
    }

    if (!hasQuery("android.intent.action.VIEW", "android.intent.category.BROWSABLE", "https")) {
      manifest["queries"].push({
        intent: [{
          action: [{ $: { "android:name": "android.intent.action.VIEW" } }],
          category: [{ $: { "android:name": "android.intent.category.BROWSABLE" } }],
          data: [{ $: { "android:scheme": "https" } }],
        }],
      });
    }

    if (!mainApplication.service) mainApplication.service = [];

    const serviceName = ".AppSwitchService"; 
    let serviceEntry = mainApplication.service.find(s => s.$["android:name"] === serviceName);

    if (!serviceEntry) {
      serviceEntry = { $: { "android:name": serviceName } };
      mainApplication.service.push(serviceEntry);
    }

    serviceEntry.$ = {
      ...serviceEntry.$,
      "android:permission": "android.permission.BIND_ACCESSIBILITY_SERVICE",
      "android:label": "ìŠ¤ìœ„ì¹­ ì„œë¹„ìŠ¤",
      "android:enabled": "true",
      "android:exported": "true", // ì‹œìŠ¤í…œ í†µë¡œ ê°œë°© (ë°˜ë“œì‹œ trueì—¬ì•¼ ì‹œìŠ¤í…œì´ ì„œë¹„ìŠ¤ ê¸°ë™ ê°€ëŠ¥)
      "android:stopWithTask": "false",
      "android:foregroundServiceType": "specialUse", 
    };

    serviceEntry["intent-filter"] = [{ action: [{ $: { "android:name": "android.accessibilityservice.AccessibilityService" } }] }];
    serviceEntry["meta-data"] = [{ $: { "android:name": "android.accessibilityservice", "android:resource": "@xml/accessibility_service_config" } }];

    return config;
  });

  // 2. MainApplication.kt ìˆ˜ì •
  config = withMainApplication(config, (config) => {
    let content = config.modResults.contents;
    if (!content.includes("add(AppSwitchPackage())")) {
      content = content.replace(
        /PackageList\(this\)\.packages\.apply \{/,
        "PackageList(this).packages.apply {\n                add(AppSwitchPackage())"
      );
      if (!content.includes("import com.switching.app.AppSwitchPackage")) {
        content = content.replace(
          /package com\.switching\.app/,
          "package com.switching.app\n\nimport com.switching.app.AppSwitchPackage"
        );
      }
    }
    config.modResults.contents = content;
    return config;
  });

  // 3. ë¬¼ë¦¬ì  íŒŒì¼ ìë™ ìƒì„± (ë³¼ë¥¨ ì°¨ë‹¨ ë¡œì§ ê°•í™”)
  return withDangerousMod(config, [
    "android",
    async (config) => {
      const projectRoot = config.modRequest.projectRoot;
      const packagePath = "com/switching/app";
      const androidPath = path.join(projectRoot, "android/app/src/main/java", packagePath);

      if (!fs.existsSync(androidPath)) {
        fs.mkdirSync(androidPath, { recursive: true });
      }

      // [ìˆ˜ì • í•µì‹¬] ë³¼ë¥¨ ë‹¤ìš´ í‚¤ì˜ ëª¨ë“  ì•¡ì…˜(DOWN/UP)ì„ ê°€ë¡œì±„ ì‹œìŠ¤í…œ ì „íŒŒë¥¼ ë§‰ìŒ
      const serviceCode = `package com.switching.app
import android.accessibilityservice.AccessibilityService
import android.view.KeyEvent
import android.view.accessibility.AccessibilityEvent
import com.facebook.react.bridge.ReactContext
import com.facebook.react.ReactApplication
import com.facebook.react.modules.core.DeviceEventManagerModule

class AppSwitchService : AccessibilityService() {
    override fun onKeyEvent(event: KeyEvent): Boolean {
        // 1. ì €ì¥ì†Œì—ì„œ í™œì„±í™” ìƒíƒœ í˜¸ì¶œ
        val prefs = getSharedPreferences("AppSwitchPrefs", android.content.Context.MODE_PRIVATE)
        val isEnabled = prefs.getBoolean("isEnabled", false)
        val targetPackage = prefs.getString("targetPackage", "") ?: "" // âœ… [ì¶”ê°€]

        // âœ… [ìˆ˜ì •] í™œì„±í™” + ë³¼ë¥¨ë‹¤ìš´ + íƒ€ê²Ÿì•± ì§€ì •ì¼ ë•Œë§Œ ê°€ë¡œì±„ê¸°(ì•ˆ ê·¸ëŸ¬ë©´ ë³¼ë¥¨ë§Œ ë§‰íˆëŠ” í˜„ìƒ ë°œìƒ)
        if (isEnabled && targetPackage.isNotEmpty() && event.keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
            if (event.action == KeyEvent.ACTION_DOWN) {

                // âœ… [ì¶”ê°€] ë„¤ì´í‹°ë¸Œì—ì„œ ì¦‰ì‹œ ì•± ì‹¤í–‰ (ReactContext/JS ì˜ì¡´ ì œê±°)
                val launchIntent = packageManager.getLaunchIntentForPackage(targetPackage)
                launchIntent?.addFlags(android.content.Intent.FLAG_ACTIVITY_NEW_TASK)
                if (launchIntent != null) {
                    startActivity(launchIntent)
                }

                // (ì„ íƒ) JSì—ë„ ì´ë²¤íŠ¸ ì „ë‹¬ (ìˆìœ¼ë©´ emit, ì—†ì–´ë„ ì•± ì‹¤í–‰ì€ ë¨)
                val reactContext = (application as ReactApplication).reactNativeHost.reactInstanceManager.currentReactContext
                reactContext?.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)?.emit("onVolumeDownTrigger", null)
            }
            return true // âœ… [ìœ ì§€] ì‹œìŠ¤í…œìœ¼ë¡œ ì´ë²¤íŠ¸ ì „íŒŒ ì°¨ë‹¨
        }

        // ë¹„í™œì„±í™” ìƒíƒœì´ê±°ë‚˜ íƒ€ê²Ÿì•± ë¯¸ì§€ì •/ë‹¤ë¥¸ í‚¤ë¼ë©´ ì‹œìŠ¤í…œ ê¸°ë³¸ ë™ì‘ ìˆ˜í–‰
        return super.onKeyEvent(event)
    }
    override fun onAccessibilityEvent(event: AccessibilityEvent) {}
    override fun onInterrupt() {}
}`;

      const moduleCode = `package com.switching.app
import android.content.Intent
import android.content.pm.PackageManager
import com.facebook.react.bridge.*

class AppSwitchModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    override fun getName(): String = "AppSwitchModule"

    @ReactMethod
    fun getInstalledApps(promise: Promise) {
        try {
            val pm = reactApplicationContext.packageManager
            val apps = pm.getInstalledApplications(PackageManager.GET_META_DATA)
            val list = Arguments.createArray()
            for (app in apps) {
                if (pm.getLaunchIntentForPackage(app.packageName) != null) {
                    val map = Arguments.createMap()
                    map.putString("label", pm.getApplicationLabel(app).toString())
                    map.putString("packageName", app.packageName)
                    list.pushMap(map)
                }
            }
            promise.resolve(list)
        } catch (e: Exception) { promise.reject("ERROR", e.message) }
    }

    @ReactMethod
    fun launchApp(packageName: String) {
        val intent = reactApplicationContext.packageManager.getLaunchIntentForPackage(packageName)
        if (intent != null) {
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            reactApplicationContext.startActivity(intent)
        }
    }
        @ReactMethod
    fun isAccessibilityServiceEnabled(promise: Promise) {
        val expectedComponentName = android.content.ComponentName(reactApplicationContext, AppSwitchService::class.java)
        val enabledServices = android.provider.Settings.Secure.getString(reactApplicationContext.contentResolver, android.provider.Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES)
        val isEnabled = enabledServices?.contains(expectedComponentName.flattenToString()) == true
        promise.resolve(isEnabled)
    }

    // [ì¶”ê°€] ì•ˆë“œë¡œì´ë“œ ì ‘ê·¼ì„± ì„¤ì • í™”ë©´ìœ¼ë¡œ ì§ì ‘ ì´ë™
    @ReactMethod
    fun openAccessibilitySettings() {
        val intent = Intent(android.provider.Settings.ACTION_ACCESSIBILITY_SETTINGS)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        reactApplicationContext.startActivity(intent)
    }

    // [ìˆ˜ì •] ë°ì´í„° ì €ì¥ì†Œ(save) ë° í˜¸ì¶œ í†µë¡œ(get) êµ¬ì¶•
    @ReactMethod
    fun saveSettings(targetPackage: String, isEnabled: Boolean) {
        val prefs = reactApplicationContext.getSharedPreferences("AppSwitchPrefs", android.content.Context.MODE_PRIVATE)
        prefs.edit().putString("targetPackage", targetPackage).putBoolean("isEnabled", isEnabled).apply()
    }

    @ReactMethod
    fun getSettings(promise: Promise) {
        val prefs = reactApplicationContext.getSharedPreferences("AppSwitchPrefs", android.content.Context.MODE_PRIVATE)
        val map = Arguments.createMap()
        map.putString("targetPackage", prefs.getString("targetPackage", ""))
        map.putBoolean("isEnabled", prefs.getBoolean("isEnabled", false))
        promise.resolve(map)
    }

    @ReactMethod
    fun addListener(eventName: String) {}

    @ReactMethod
    fun removeListeners(count: Int) {}
}`;

      const packageCode = `package com.switching.app
import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class AppSwitchPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> = listOf(AppSwitchModule(reactContext))
    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> = emptyList()
}`;

      const xmlDir = path.join(projectRoot, "android/app/src/main/res/xml");
      if (!fs.existsSync(xmlDir)) fs.mkdirSync(xmlDir, { recursive: true });
      const xmlContent = `<?xml version="1.0" encoding="utf-8"?>
<accessibility-service xmlns:android="http://schemas.android.com/apk/res/android"
    android:accessibilityEventTypes="typeAllMask"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:accessibilityFlags="flagRequestFilterKeyEvents"
    android:canRetrieveWindowContent="false"
    android:canRequestFilterKeyEvents="true"
    android:description="@string/app_name" />`;

      fs.writeFileSync(path.join(androidPath, "AppSwitchService.kt"), serviceCode);
      fs.writeFileSync(path.join(androidPath, "AppSwitchModule.kt"), moduleCode);
      fs.writeFileSync(path.join(androidPath, "AppSwitchPackage.kt"), packageCode);
      fs.writeFileSync(path.join(xmlDir, "accessibility_service_config.xml"), xmlContent);

      console.log("âœ… [withAppSwitch] ëª¨ë“  ë¡œì§ í†µí•© ìˆ˜ì • ì™„ë£Œ!");
      return config;
    },
  ]);
};

================================================================================
 FILE: scripts\reset-project.js
================================================================================

#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`ğŸ“ /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`â¡ï¸ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`âŒ /${dir} deleted.`);
        }
      } else {
        console.log(`â¡ï¸ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\nğŸ“ New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("ğŸ“„ app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("ğŸ“„ app/_layout.tsx created.");

    console.log("\nâœ… Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`âŒ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("âŒ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);

